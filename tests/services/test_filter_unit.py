"""
test: services/scanner/test_filter_unit.py

Test unitari per il modulo servizio filtro.
Questo modulo valida la logica per filtrare i risultati ScanCode, inclusi:
- Costruzione di rappresentazioni JSON minime.
- Rimozione dei file di licenza principale dall'analisi.
- Filtraggio basato su regex di corrispondenze invalide o irrilevanti.
- Gestione di voci di licenza duplicate.
- Logica per filtrare licenze contenute/sottoinsiemi.
"""

import pytest
import json
import os
import re
from unittest.mock import patch, mock_open

# Import functions to be tested
from app.services.scanner.filter import (
    filter_licenses,
    build_minimal_json,
    remove_main_license,
    regex_filter,
    check_license_spdx_duplicates,
    filter_contained_licenses
)

# --- FIXTURE ---

@pytest.fixture(autouse=True)
def setup_filter_test_env():
    """
    Configura l'ambiente per tutti i test.
    Patchea MINIMAL_JSON_BASE_DIR direttamente nel modulo scanner.filter
    e mocka os.makedirs per prevenire cambiamenti del file system.
    """
    # This patch only works if MINIMAL_JSON_BASE_DIR is imported correctly in filter.py
    with patch("app.services.scanner.filter.MINIMAL_JSON_BASE_DIR", "/mock/dir"), \
            patch("os.makedirs"):
        yield

@pytest.fixture
def mock_scancode_data():
    """
    Fixture che fornisce una struttura dati di esempio grezza da ScanCode.
    Contiene file legali e illegali con vari tipi di corrispondenza.
    """
    return {
        "files": [
            {
                "path": "file1.py",
                "is_legal": False,
                "is_key_file": False,
                "percentage_of_license_text": 90.5,
                "license_detections": [
                    {
                        "matches": [
                            {
                                "from_file": "file1.py",
                                "license_expression_spdx": "MIT",
                                "matched_text": "Permission is hereby granted..."
                            },
                            {
                                "from_file": "file1.py",
                                "license_expression_spdx": "LicenseRef-scancode-unknown",
                                "matched_text": "foobar"
                            }
                        ]
                    }
                ]
            },
            {
                "path": "README.md",
                "is_legal": False,
                "is_key_file": False,
                "percentage_of_license_text": 10.0,
                "license_detections": [
                    {
                        "matches": [
                            {
                                "from_file": "README.md",
                                "license_expression_spdx": "MIT",
                                "matched_text": "See the MIT license file for details."
                            }
                        ]
                    }
                ]
            }
        ]
    }

@pytest.fixture
def mock_rules_json():
    """
    Fixture che simula il contenuto di license_rules.json.
    Definisce pattern per testo ignorato, changelog, tag SPDX e link validi.
    """
    return {
        "ignore_patterns": [
            "(see\\s+(the\\s+)?license\\s+file)",
            "generated by"
        ],
        "changelog_patterns": [
            "migrated to"
        ],
        "spdx_tag_pattern": "SPDX-License-Identifier:\\s*([\\w\\.\\-\\+]+)",
        "valid_license_text_patterns": [
            "Permission is hereby granted",
            "Licensed under the Apache License"
        ],
        "valid_license_link_patterns": [
            "https?://opensource\\.org/licenses/"
        ],
        "min_matched_text_length": 10
    }

# --- TEST UNITARI: build_minimal_json ---

def test_build_minimal_json(mock_scancode_data):
    """
    Testa la creazione standard della struttura JSON minima.
    Verifica che i file siano correttamente analizzati e mappati allo schema minimo.
    """
    with patch("builtins.open", mock_open()) as mocked_file, \
            patch("os.makedirs") as mock_makedirs:
        result = build_minimal_json(mock_scancode_data)

        # Verify dummy path patched by fixture
        mock_makedirs.assert_called_with("/mock/dir", exist_ok=True)

        files = result["files"]
        assert len(files) == 2
        f1 = files[0]
        assert f1["path"] == "file1.py"
        assert len(f1["matches"]) == 1
        assert f1["matches"][0]["license_spdx"] == "MIT"

def test_build_minimal_json_edge_cases():
    """
    Testa casi limite per build_minimal_json:
    - 'path' mancante nella voce file.
    - Mancata corrispondenza tra 'path' e 'from_file'.
    Verifica che voci invalide siano escluse.
    """
    data = {
        "files": [
            {"path": None},
            {
                "path": "a.py",
                "is_legal": False, "is_key_file": False, "percentage_of_license_text": 0,
                "license_detections": [{
                    "matches": [{
                        "from_file": "other.py",
                        "license_expression_spdx": "MIT",
                        "matched_text": "text"
                    }]
                }]
            }
        ]
    }
    with patch("builtins.open", mock_open()), \
            patch("os.makedirs"):
        res = build_minimal_json(data)
        assert len(res["files"]) == 0

# --- UNIT TESTS: remove_main_license ---

def test_remove_main_license_single():
    """
    Testa la rimozione del file di licenza principale dalla lista.
    Verifica che se un file corrisponde al percorso/SPDX della licenza principale, sia filtrato.
    """
    data = {
        "files": [
            {"path": "LICENSE", "matches": [{"license_spdx": "MIT"}]},
            {"path": "app.py", "matches": [{"license_spdx": "Apache-2.0"}]}
        ]
    }
    result = remove_main_license("MIT", "LICENSE", data)
    assert len(result["files"]) == 1
    assert result["files"][0]["path"] == "app.py"

def test_remove_main_license_multiple_matches_value_error():
    """
    Testa il comportamento quando il file target ha più corrispondenze di licenza.
    Garantisce una gestione rigorosa dove file ambigui potrebbero essere rimossi o gestiti con grazia.
    """
    data = {
        "files": [
            {
                "path": "target.py",
                "matches": [
                    {"license_spdx": "MIT"},
                    {"license_spdx": "MIT"}
                ]
            }
        ]
    }
    result = remove_main_license("MIT", "target.py", data)
    assert len(result["files"]) == 0

def test_remove_main_license_value_error():
    """
    Test that ValueError during removal is caught and ignored.
    This simulates a race condition or state where the item to be removed
    is no longer in the list by the time remove() is called.
    """
    class ErrorList(list):
        def remove(self, value):
            raise ValueError("Test Error")

    # Construct the data with the custom list
    file_entry = {"path": "target.py", "matches": [{"license_spdx": "MIT"}]}
    files_list = ErrorList([file_entry])
    data = {"files": files_list}

    # This should find "target.py" with "MIT" and try to remove it, triggering ValueError
    result = remove_main_license("MIT", "target.py", data)

    # Result should still contain the file because removal failed and was caught
    assert len(result["files"]) == 1
    assert result["files"][0]["path"] == "target.py"

def test_remove_main_license_path_match_spdx_mismatch():
    """
    Test that if the path matches the main license file but the SPDX does not,
    the file is NOT removed.
    """
    data = {
        "files": [
            {"path": "LICENSE", "matches": [{"license_spdx": "Apache-2.0"}]}
        ]
    }
    # Trying to remove "LICENSE" assuming it is "MIT". It is "Apache-2.0".
    result = remove_main_license("MIT", "LICENSE", data)
    assert len(result["files"]) == 1
    assert result["files"][0]["path"] == "LICENSE"

# --- UNIT TESTS: filter_contained_licenses ---

def test_filter_contained_licenses_logic():
    """
    Testa la logica per filtrare licenze ridondanti contenute in altre espressioni di licenza.
    Esempio: 'MIT' dovrebbe essere rimosso se 'Apache-2.0 AND MIT' è presente.
    """
    items = [
        {"license_spdx": "MIT"},
        {"license_spdx": "Apache-2.0 AND MIT"}
    ]
    res = filter_contained_licenses(items)
    assert len(res) == 1
    assert res[0]["license_spdx"] == "Apache-2.0 AND MIT"

def test_filter_contained_licenses_dirty_inputs():
    """
    Testa la robustezza di filter_contained_licenses contro input sporchi
    come stringhe vuote o valori None.
    """
    items = [
        {"license_spdx": ""},
        {"license_spdx": None},
        {"license_spdx": "MIT"}
    ]
    res = filter_contained_licenses(items)
    assert len(res) == 3

# --- TEST UNITARI: regex_filter ---

def test_regex_filter_missing_rules_file():
    """
    Verifica che regex_filter sollevi FileNotFoundError se il file regole è mancante.
    """
    with patch("os.path.exists", return_value=False):
        with pytest.raises(FileNotFoundError):
            regex_filter({"files": []}, False)

def test_load_rules_patterns_invalid_regex(mock_rules_json):
    """
    Test that invalid regex patterns in rules file are safely ignored (caught by try/except).
    """
    bad_rules = mock_rules_json.copy()
    bad_rules["valid_license_text_patterns"] = ["(["] # Invalid regex
    bad_rules["valid_license_link_patterns"] = ["*"]  # Invalid regex

    with patch("builtins.open", mock_open(read_data=json.dumps(bad_rules))), \
            patch("os.path.exists", return_value=True):
        # Should not raise exception
        result = regex_filter({"files": []}, False)
        assert result == {"files": []}

def test_regex_filter_skip_key_files(mock_rules_json):
    """
    Test that files marked as 'is_key_file' are skipped ONLY when detected_main_spdx is True.
    """
    data = {
        "files": [
            {
                "path": "LICENSE",
                "is_legal": False, # Must be False to hit the check
                "is_key_file": True,
                "score": 100,
                # Use matched_text that passes regex validation ("Permission is hereby granted")
                # defined in mock_rules_json, otherwise the file is filtered out as invalid match
                "matches": [{"license_spdx": "MIT", "matched_text": "Permission is hereby granted"}]
            }
        ]
    }

    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):

        # Scenario 1: detected_main_spdx = True -> File skipped (key file)
        res1 = regex_filter(data, detected_main_spdx=True)
        assert len(res1["files"]) == 0

        # Scenario 2: detected_main_spdx = False -> File kept (key file check ignored)
        res2 = regex_filter(data, detected_main_spdx=False)
        assert len(res2["files"]) == 1

def test_regex_filter_detected_main_true_not_key_file(mock_rules_json):
    """
    Test that if detected_main_spdx is True but is_key_file is False,
    the file is NOT skipped.
    """
    data = {
        "files": [{
            "path": "normal.py",
            "is_legal": False,
            "is_key_file": False, # Not a key file
            "matches": [{"license_spdx": "MIT", "matched_text": "Permission is hereby granted"}]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, detected_main_spdx=True)
        assert len(result["files"]) == 1

def test_regex_filter_is_legal_file(mock_rules_json):
    """
    Test that files marked as 'is_legal' are preserved in the output
    without undergoing regex filtering.
    """
    data = {
        "files": [{
            "path": "legal_file.txt",
            "is_legal": True,
            "is_key_file": False,
            "score": 100,
            # Even with matches that might technically fail validation (or empty matches),
            # legal files are passed through "as is" by the filter logic.
            "matches": [{"license_spdx": "SomeLicense", "matched_text": "Some text"}]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        assert len(result["files"]) == 1
        assert result["files"][0]["path"] == "legal_file.txt"
        # Matches should be preserved as-is
        assert result["files"][0]["matches"][0]["license_spdx"] == "SomeLicense"

def test_regex_filter_valid_tag_group_1(mock_rules_json):
    """
    Testa il filtraggio regex utilizzando il primo gruppo di cattura di un pattern.
    Verifica l'estrazione dell'ID SPDX da tag come 'SPDX-License-Identifier: MIT'.
    """
    data = {
        "files": [{
            "path": "file.c", "is_legal": False, "is_key_file": False, "score": 50,
            "matches": [{
                "license_spdx": "MIT",
                "matched_text": "SPDX-License-Identifier: MIT"
            }]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        assert len(result["files"]) == 1
        assert result["files"][0]["matches"][0]["license_spdx"] == "MIT"

def test_regex_filter_spdx_tag_group_3(mock_rules_json):
    """
    Testa il filtraggio regex con pattern complessi che coinvolgono più gruppi.
    Verifica che il gruppo corretto (3° in questo caso) sia estratto.
    """
    custom_rules = mock_rules_json.copy()
    custom_rules["spdx_tag_pattern"] = "(Tag: (.+))|(Alt: (.+))"
    data = {
        "files": [{
            "path": "file.c", "is_legal": False, "is_key_file": False, "score": 50,
            "matches": [{
                "license_spdx": "MIT",
                "matched_text": "Alt: Apache-2.0"
            }]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(custom_rules))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        assert len(result["files"]) == 1
        assert "Apache-2.0" in result["files"][0]["matches"][0]["license_spdx"]

def test_regex_filter_valid_link_fallback(mock_rules_json):
    """
    Testa il comportamento di fallback quando il testo di licenza è sconosciuto ma contiene un URL valido.
    Verifica che la voce sia mantenuta se l'URL corrisponde a pattern consentiti.
    """
    data = {
        "files": [{
            "path": "link.txt", "is_legal": False, "is_key_file": False, "score": 50,
            "matches": [{
                "license_spdx": "LicenseRef-scancode-unknown",
                "matched_text": "Check https://opensource.org/licenses/MIT"
            }]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        assert len(result["files"]) == 1
        assert result["files"][0]["matches"][0]["license_spdx"] == "LicenseRef-scancode-unknown"

def test_regex_filter_scancode_id_checks(mock_rules_json):
    """
    Testa la gestione di ID interni specifici di ScanCode (ad es., LicenseRef-scancode-generic).
    Verifica che ID 'generic' siano trattati diversamente da licenze valide o ref sconosciuti.
    """
    data = {
        "files": [{
            "path": "checks.txt", "is_legal": False, "is_key_file": False, "score": 50,
            "matches": [
                {"license_spdx": "LicenseRef-scancode-generic",
                 "matched_text": "Valid Link: https://opensource.org/licenses/MIT"},
                {"license_spdx": "LicenseRef-unknown-license",
                 "matched_text": "Valid Link: https://opensource.org/licenses/MIT"},
                {"license_spdx": "Apache-2.0", "matched_text": "Valid Link: https://opensource.org/licenses/MIT"}
            ]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        matches = result["files"][0]["matches"]
        assert matches[0]["license_spdx"] == "LicenseRef-scancode-unknown"
        assert matches[1]["license_spdx"] == "LicenseRef-scancode-unknown"
        assert matches[2]["license_spdx"] == "Apache-2.0"

def test_regex_filter_no_valid_matches(mock_rules_json):
    """
    Test that files with no valid matches (text not in whitelist) are excluded from output.
    """
    data = {
        "files": [{
            "path": "garbage.txt", "is_legal": False, "is_key_file": False, "score": 10,
            "matches": [{"license_spdx": "MIT", "matched_text": "This text is not in the whitelist rules."}]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        # File should be dropped because valid_matches is empty
        assert len(result["files"]) == 0

def test_regex_filter_empty_extraction(mock_rules_json):
    """
    Test scenario where SPDX tag regex matches but captures an empty string.
    The match should be discarded.
    """
    # Rule that matches "Tag: " but captures "" in group 1
    custom_rules = mock_rules_json.copy()
    custom_rules["spdx_tag_pattern"] = "Tag: (.*)"

    data = {
        "files": [{
            "path": "empty.txt", "is_legal": False, "is_key_file": False, "score": 10,
            "matches": [{"license_spdx": "MIT", "matched_text": "Tag: "}]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(custom_rules))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        # Match matches regex, but extracted group is empty string.
        # final_spdx becomes "", so 'if final_spdx:' is False.
        # valid_matches empty -> file dropped.
        assert len(result["files"]) == 0

# --- UNIT TESTS: check_license_spdx_duplicates ---

def test_check_license_spdx_duplicates_dirty_data():
    """
    Testa il controllo duplicati con dati sporchi (None o stringhe vuote).
    Verifica che valori invalidi siano puliti mentre quelli validi rimangano.
    """
    data = {
        "files": [
            {
                "path": "test.py", "score": 100,
                "matches": [
                    {"license_spdx": None, "matched_text": "t1"},
                    {"license_spdx": "", "matched_text": "t2"},
                    {"license_spdx": "MIT", "matched_text": "t3"}
                ]
            }
        ]
    }
    result = check_license_spdx_duplicates(data)
    matches = result["files"][0]["matches"]
    assert len(matches) == 1
    assert matches[0]["license_spdx"] == "MIT"

def test_check_license_spdx_duplicates_deduplication():
    """
    Testa la logica di deduplicazione per ID SPDX identici.
    Verifica che duplicati case-insensitive siano uniti.
    """
    data = {
        "files": [{
            "path": "test.py", "score": 100,
            "matches": [
                {"license_spdx": "MIT", "matched_text": "t1"},
                {"license_spdx": "mit", "matched_text": "t2"}
            ]
        }]
    }
    result = check_license_spdx_duplicates(data)
    assert len(result["files"][0]["matches"]) == 1

def test_check_license_spdx_duplicates_all_invalid():
    """
    Test scenario where a file has matches but all have invalid/empty SPDX.
    The file should be excluded from the unique results.
    """
    data = {
        "files": [{
            "path": "invalid.txt", "score": 10,
            "matches": [
                {"license_spdx": "", "matched_text": "foo"},
                {"license_spdx": None, "matched_text": "bar"}
            ]
        }]
    }
    result = check_license_spdx_duplicates(data)
    # spdx_uniques should be empty, so file is not appended
    assert len(result["files"]) == 0

# --- INTEGRATION TESTS ---

def test_filter_licenses_integration(mock_scancode_data, mock_rules_json):
    """
    Test di integrazione per la funzione principale filter_licenses.
    Verifica che l'intera pipeline (carica, filtra, rimuovi principale, pulisci) funzioni insieme.
    """
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = filter_licenses(mock_scancode_data, main_spdx="UNKNOWN", path="")
        assert len(result["files"]) == 1
        assert result["files"][0]["path"] == "file1.py"