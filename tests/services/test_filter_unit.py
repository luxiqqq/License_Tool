import pytest
import json
import os
import re
import sys
from unittest.mock import patch, mock_open

# Importa le funzioni da testare
from app.services.scanner.filter import (
    filter_licenses,
    build_minimal_json,
    remove_main_license,
    regex_filter,
    check_license_spdx_duplicates,
    filter_contained_licenses
)
# Importiamo anche il modulo stesso per manipolare i globals nei test avanzati
import app.services.scanner.filter as filter_module


# --- FIXTURES ---

@pytest.fixture
def mock_scancode_data():
    """Dati di esempio grezzi da Scancode."""
    return {
        "files": [
            {
                "path": "file1.py",
                "is_legal": False,
                "is_key_file": False,
                "percentage_of_license_text": 90.5,
                "license_detections": [
                    {
                        "matches": [
                            {
                                "from_file": "file1.py",
                                "license_expression_spdx": "MIT",
                                "matched_text": "Permission is hereby granted..."
                            },
                            {
                                "from_file": "file1.py",
                                "license_expression_spdx": "LicenseRef-scancode-unknown",
                                "matched_text": "foobar"
                            }
                        ]
                    }
                ]
            },
            {
                "path": "README.md",
                "is_legal": False,
                "is_key_file": False,
                "percentage_of_license_text": 10.0,
                "license_detections": [
                    {
                        "matches": [
                            {
                                "from_file": "README.md",
                                "license_expression_spdx": "MIT",
                                "matched_text": "See the MIT license file for details."
                            }
                        ]
                    }
                ]
            }
        ]
    }


@pytest.fixture
def mock_rules_json():
    """Contenuto simulato di license_rules.json."""
    return {
        "ignore_patterns": [
            "(see\\s+(the\\s+)?license\\s+file)",
            "generated by"
        ],
        "changelog_patterns": [
            "migrated to"
        ],
        # Regex standard semplificata
        "spdx_tag_pattern": "SPDX-License-Identifier:\\s*([\\w\\.\\-\\+]+)",
        "valid_license_text_patterns": [
            "Permission is hereby granted",
            "Licensed under the Apache License"
        ],
        "valid_license_link_patterns": [
            "https?://opensource\\.org/licenses/"
        ],
        "min_matched_text_length": 10
    }


# --- TEST UNITARI: build_minimal_json ---

def test_build_minimal_json(mock_scancode_data):
    """Testa la creazione standard del JSON minimale."""
    with patch("builtins.open", mock_open()) as mocked_file, \
            patch("os.makedirs") as mock_makedirs, \
            patch("app.services.scanner.filter.MINIMAL_JSON_BASE_DIR", "/tmp/test"):
        result = build_minimal_json(mock_scancode_data)
        mock_makedirs.assert_called_with("/tmp/test", exist_ok=True)

        files = result["files"]
        assert len(files) == 2
        f1 = files[0]
        assert f1["path"] == "file1.py"
        assert len(f1["matches"]) == 1
        assert f1["matches"][0]["license_spdx"] == "MIT"
        assert f1["score"] == 90.5


def test_build_minimal_json_edge_cases():
    """Testa casi limite: path mancante e mismatch from_file."""
    data = {
        "files": [
            {"path": None},  # Deve essere saltato (path None)
            {
                "path": "a.py",
                "is_legal": False, "is_key_file": False, "percentage_of_license_text": 0,
                "license_detections": [{
                    "matches": [{
                        "from_file": "other.py",  # Mismatch path -> saltato
                        "license_expression_spdx": "MIT",
                        "matched_text": "text"
                    }]
                }]
            }
        ]
    }
    with patch("builtins.open", mock_open()), \
            patch("os.makedirs"), \
            patch("app.services.scanner.filter.MINIMAL_JSON_BASE_DIR", "/tmp"):
        res = build_minimal_json(data)
        assert len(res["files"]) == 0


# --- TEST UNITARI: remove_main_license ---

def test_remove_main_license_single():
    """Testa la rimozione normale di un file."""
    data = {
        "files": [
            {"path": "LICENSE", "matches": [{"license_spdx": "MIT"}]},
            {"path": "app.py", "matches": [{"license_spdx": "Apache-2.0"}]}
        ]
    }
    result = remove_main_license("MIT", "LICENSE", data)
    assert len(result["files"]) == 1
    assert result["files"][0]["path"] == "app.py"


def test_remove_main_license_multiple_matches_value_error():
    """
    Testa il blocco try-except ValueError.
    Scenario: Un file ha 2 match 'MIT'.
    Loop 1: Rimuove il file.
    Loop 2: Tenta di rimuovere lo stesso file -> ValueError -> catch e continue.
    """
    data = {
        "files": [
            {
                "path": "target.py",
                "matches": [
                    {"license_spdx": "MIT"},
                    {"license_spdx": "MIT"}  # Triggera la seconda remove()
                ]
            }
        ]
    }
    result = remove_main_license("MIT", "target.py", data)
    assert len(result["files"]) == 0


# --- TEST UNITARI: filter_contained_licenses ---

def test_filter_contained_licenses_logic():
    """Testa logica base e check 'contained'."""
    items = [
        {"license_spdx": "MIT"},
        {"license_spdx": "Apache-2.0 AND MIT"}
    ]
    res = filter_contained_licenses(items)
    assert len(res) == 1
    assert res[0]["license_spdx"] == "Apache-2.0 AND MIT"

    # Nessuna inclusione (boundary check)
    items_boundary = [
        {"license_spdx": "MIT"},
        {"license_spdx": "MIT-0"}
    ]
    res_boundary = filter_contained_licenses(items_boundary)
    assert len(res_boundary) == 2


def test_filter_contained_licenses_dirty_inputs():
    """Testa input sporchi (None, stringhe vuote) per coprire 'if not spdx_i'."""
    items = [
        {"license_spdx": ""},  # Empty
        {"license_spdx": None},  # None
        {"license_spdx": "MIT"}
    ]
    res = filter_contained_licenses(items)
    # Nessuno viene rimosso perché non matchano come sotto-stringhe valide
    assert len(res) == 3


# --- TEST UNITARI: regex_filter ---

def test_regex_filter_missing_rules_file():
    """Copertura: FileNotFoundError."""
    with patch("os.path.exists", return_value=False):
        with pytest.raises(FileNotFoundError):
            regex_filter({"files": []}, False)


def test_regex_filter_valid_tag_group_1(mock_rules_json):
    """Testa match con gruppo 1 (standard)."""
    data = {
        "files": [{
            "path": "file.c", "is_legal": False, "is_key_file": False, "score": 50,
            "matches": [{
                "license_spdx": "MIT",
                "matched_text": "SPDX-License-Identifier: MIT"
            }]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        assert len(result["files"]) == 1
        assert result["files"][0]["matches"][0]["license_spdx"] == "MIT"


def test_regex_filter_spdx_tag_group_3(mock_rules_json):
    """
    Testa il ramo 'or spdx_tag_hit.group(3)'.
    Usiamo una regex custom che simula il formato 'plain' dove il primo gruppo è vuoto.
    """
    custom_rules = mock_rules_json.copy()
    custom_rules["spdx_tag_pattern"] = "(Tag: (.+))|(Alt: (.+))"

    data = {
        "files": [{
            "path": "file.c", "is_legal": False, "is_key_file": False, "score": 50,
            "matches": [{
                "license_spdx": "MIT",
                "matched_text": "Alt: Apache-2.0"
            }]
        }]
    }

    with patch("builtins.open", mock_open(read_data=json.dumps(custom_rules))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)

        assert len(result["files"]) == 1
        assert "Alt: Apache-2.0" in result["files"][0]["matches"][0]["license_spdx"]


def test_regex_filter_valid_link_fallback(mock_rules_json):
    """Testa Case 3: Fallback ID quando scancode ID è sconosciuto ma link è valido."""
    data = {
        "files": [{
            "path": "link.txt", "is_legal": False, "is_key_file": False, "score": 50,
            "matches": [{
                "license_spdx": "LicenseRef-scancode-unknown",
                "matched_text": "Check https://opensource.org/licenses/MIT"
            }]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        assert len(result["files"]) == 1
        assert result["files"][0]["matches"][0]["license_spdx"] == "LicenseRef-scancode-unknown"


def test_regex_filter_scancode_id_checks(mock_rules_json):
    """
    Testa la logica di fallback per gli ID 'sporchi' di Scancode.
    Se un ID contiene "scancode" o "unknown" e non c'è un tag esplicito,
    il codice forza il fallback a "LicenseRef-scancode-unknown".
    """
    data = {
        "files": [{
            "path": "checks.txt", "is_legal": False, "is_key_file": False, "score": 50,
            "matches": [
                # Caso: 'scancode' in ID -> Forza fallback (anche se c'è link valido)
                {"license_spdx": "LicenseRef-scancode-generic",
                 "matched_text": "Valid Link: https://opensource.org/licenses/MIT"},
                # Caso: 'unknown' in ID -> Forza fallback
                {"license_spdx": "LicenseRef-unknown-license",
                 "matched_text": "Valid Link: https://opensource.org/licenses/MIT"},
                # Caso: ID Valido
                {"license_spdx": "Apache-2.0", "matched_text": "Valid Link: https://opensource.org/licenses/MIT"}
            ]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        matches = result["files"][0]["matches"]

        # 1. LicenseRef-scancode-generic -> Contiene "scancode" -> Invalid -> Fallback
        assert matches[0]["license_spdx"] == "LicenseRef-scancode-unknown"

        # 2. LicenseRef-unknown-license -> Contiene "unknown" -> Invalid -> Fallback
        assert matches[1]["license_spdx"] == "LicenseRef-scancode-unknown"

        # 3. Apache-2.0 -> Valido
        assert matches[2]["license_spdx"] == "Apache-2.0"


def test_regex_filter_resilience_to_bad_regex(mock_rules_json):
    """Testa resilienza a regex malformate nel JSON."""
    mock_rules_json["valid_license_text_patterns"].append("(unclosed group")
    mock_rules_json["valid_license_link_patterns"].append("[unclosed class")

    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        # Non deve lanciare eccezioni
        regex_filter({"files": []}, False)


def test_regex_filter_skip_key_files_if_main_detected(mock_rules_json):
    """Testa logica detected_main_spdx=True."""
    data = {
        "files": [{
            "path": "README.md",
            "is_legal": False, "is_key_file": True, "score": 50,
            "matches": [{"license_spdx": "MIT", "matched_text": "Permission is hereby granted..."}]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result_true = regex_filter(data, detected_main_spdx=True)
        assert len(result_true["files"]) == 0

        result_false = regex_filter(data, detected_main_spdx=False)
        assert len(result_false["files"]) == 1


def test_regex_filter_changelog_discard(mock_rules_json):
    """Testa scarto pattern changelog."""
    data = {
        "files": [{
            "path": "CHANGELOG.md",
            "is_legal": False, "is_key_file": False, "score": 50,
            "matches": [{"license_spdx": "MIT", "matched_text": "This library migrated to MIT license."}]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, detected_main_spdx=False)
        assert len(result["files"]) == 0


def test_regex_filter_globals_fallback(mock_rules_json):
    """
    Testa il fallback di globals().get('MINIMAL_JSON_BASE_DIR', './output').
    Rimuoviamo temporaneamente la variabile dal modulo per forzare l'uso del default.
    """
    original_var = getattr(filter_module, 'MINIMAL_JSON_BASE_DIR', None)

    if hasattr(filter_module, 'MINIMAL_JSON_BASE_DIR'):
        delattr(filter_module, 'MINIMAL_JSON_BASE_DIR')

    data = {"files": []}

    try:
        with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
                patch("os.path.exists", return_value=True), \
                patch("os.makedirs") as mock_makedirs:

            regex_filter(data, False)
            mock_makedirs.assert_called_with("./output", exist_ok=True)

    finally:
        if original_var is not None:
            setattr(filter_module, 'MINIMAL_JSON_BASE_DIR', original_var)


# --- TEST UNITARI: check_license_spdx_duplicates ---

def test_check_license_spdx_duplicates_dirty_data():
    """Testa resilienza a spdx nulli o vuoti."""
    data = {
        "files": [
            {
                "path": "test.py", "score": 100,
                "matches": [
                    {"license_spdx": None, "matched_text": "t1"},
                    {"license_spdx": "", "matched_text": "t2"},
                    {"license_spdx": "MIT", "matched_text": "t3"}
                ]
            }
        ]
    }
    result = check_license_spdx_duplicates(data)
    matches = result["files"][0]["matches"]
    assert len(matches) == 1
    assert matches[0]["license_spdx"] == "MIT"


def test_check_license_spdx_duplicates_deduplication():
    """Testa deduplicazione case-insensitive."""
    data = {
        "files": [{
            "path": "test.py", "score": 100,
            "matches": [
                {"license_spdx": "MIT", "matched_text": "t1"},
                {"license_spdx": "mit", "matched_text": "t2"}
            ]
        }]
    }
    result = check_license_spdx_duplicates(data)
    assert len(result["files"][0]["matches"]) == 1


# --- TEST DI INTEGRAZIONE ---

def test_filter_licenses_integration(mock_scancode_data, mock_rules_json):
    """Testa il flusso completo."""
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True), \
            patch("os.makedirs"), \
            patch("app.services.scanner.filter.MINIMAL_JSON_BASE_DIR", "/tmp/test"):
        result = filter_licenses(mock_scancode_data, main_spdx="UNKNOWN", path="")
        assert len(result["files"]) == 1
        assert result["files"][0]["path"] == "file1.py"


def test_filter_licenses_integration_with_main_detected(mock_scancode_data, mock_rules_json):
    """Testa il flusso quando viene passato un main_spdx valido."""
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True), \
            patch("os.makedirs"), \
            patch("app.services.scanner.filter.MINIMAL_JSON_BASE_DIR", "/tmp/test"):
        result = filter_licenses(mock_scancode_data, main_spdx="Apache-2.0", path="dummy")
        assert len(result["files"]) == 1