"""
test: services/scanner/test_filter_unit.py

Unit tests for the filter service module.
This module validates the logic for filtering ScanCode results, including:
- Building minimal JSON representations.
- Removing main license files from analysis.
- Regex-based filtering of invalid or irrelevant matches.
- Handling duplicate license entries.
- Logic for filtering contained/subset licenses.
"""

import pytest
import json
import os
import re
from unittest.mock import patch, mock_open

# Import functions to be tested
from app.services.scanner.filter import (
    filter_licenses,
    build_minimal_json,
    remove_main_license,
    regex_filter,
    check_license_spdx_duplicates,
    filter_contained_licenses
)

# --- FIXTURES ---

@pytest.fixture(autouse=True)
def setup_filter_test_env():
    """
    Configures the environment for all tests.
    Patches MINIMAL_JSON_BASE_DIR directly in the scanner.filter module
    and mocks os.makedirs to prevent file system changes.
    """
    # This patch only works if MINIMAL_JSON_BASE_DIR is imported correctly in filter.py
    with patch("app.services.scanner.filter.MINIMAL_JSON_BASE_DIR", "/mock/dir"), \
            patch("os.makedirs"):
        yield

@pytest.fixture
def mock_scancode_data():
    """
    Fixture providing raw sample data structure from ScanCode.
    Contains legal and illegal files with various match types.
    """
    return {
        "files": [
            {
                "path": "file1.py",
                "is_legal": False,
                "is_key_file": False,
                "percentage_of_license_text": 90.5,
                "license_detections": [
                    {
                        "matches": [
                            {
                                "from_file": "file1.py",
                                "license_expression_spdx": "MIT",
                                "matched_text": "Permission is hereby granted..."
                            },
                            {
                                "from_file": "file1.py",
                                "license_expression_spdx": "LicenseRef-scancode-unknown",
                                "matched_text": "foobar"
                            }
                        ]
                    }
                ]
            },
            {
                "path": "README.md",
                "is_legal": False,
                "is_key_file": False,
                "percentage_of_license_text": 10.0,
                "license_detections": [
                    {
                        "matches": [
                            {
                                "from_file": "README.md",
                                "license_expression_spdx": "MIT",
                                "matched_text": "See the MIT license file for details."
                            }
                        ]
                    }
                ]
            }
        ]
    }

@pytest.fixture
def mock_rules_json():
    """
    Fixture simulating the content of license_rules.json.
    Defines patterns for ignored text, changelogs, SPDX tags, and valid links.
    """
    return {
        "ignore_patterns": [
            "(see\\s+(the\\s+)?license\\s+file)",
            "generated by"
        ],
        "changelog_patterns": [
            "migrated to"
        ],
        "spdx_tag_pattern": "SPDX-License-Identifier:\\s*([\\w\\.\\-\\+]+)",
        "valid_license_text_patterns": [
            "Permission is hereby granted",
            "Licensed under the Apache License"
        ],
        "valid_license_link_patterns": [
            "https?://opensource\\.org/licenses/"
        ],
        "min_matched_text_length": 10
    }

# --- UNIT TESTS: build_minimal_json ---

def test_build_minimal_json(mock_scancode_data):
    """
    Test the standard creation of the minimal JSON structure.
    Verifies that files are correctly parsed and mapped to the minimal schema.
    """
    with patch("builtins.open", mock_open()) as mocked_file, \
            patch("os.makedirs") as mock_makedirs:
        result = build_minimal_json(mock_scancode_data)

        # Verify dummy path patched by fixture
        mock_makedirs.assert_called_with("/mock/dir", exist_ok=True)

        files = result["files"]
        assert len(files) == 2
        f1 = files[0]
        assert f1["path"] == "file1.py"
        assert len(f1["matches"]) == 1
        assert f1["matches"][0]["license_spdx"] == "MIT"

def test_build_minimal_json_edge_cases():
    """
    Test edge cases for build_minimal_json:
    - Missing 'path' in file entry.
    - Mismatch between 'path' and 'from_file'.
    Verifies that invalid entries are excluded.
    """
    data = {
        "files": [
            {"path": None},
            {
                "path": "a.py",
                "is_legal": False, "is_key_file": False, "percentage_of_license_text": 0,
                "license_detections": [{
                    "matches": [{
                        "from_file": "other.py",
                        "license_expression_spdx": "MIT",
                        "matched_text": "text"
                    }]
                }]
            }
        ]
    }
    with patch("builtins.open", mock_open()), \
            patch("os.makedirs"):
        res = build_minimal_json(data)
        assert len(res["files"]) == 0

# --- UNIT TESTS: remove_main_license ---

def test_remove_main_license_single():
    """
    Test removing the main license file from the list.
    Verifies that if a file matches the main license path/SPDX, it is filtered out.
    """
    data = {
        "files": [
            {"path": "LICENSE", "matches": [{"license_spdx": "MIT"}]},
            {"path": "app.py", "matches": [{"license_spdx": "Apache-2.0"}]}
        ]
    }
    result = remove_main_license("MIT", "LICENSE", data)
    assert len(result["files"]) == 1
    assert result["files"][0]["path"] == "app.py"

def test_remove_main_license_multiple_matches_value_error():
    """
    Test behavior when the target file has multiple license matches.
    Ensure strict handling where ambiguous files might be removed or handled gracefully.
    """
    data = {
        "files": [
            {
                "path": "target.py",
                "matches": [
                    {"license_spdx": "MIT"},
                    {"license_spdx": "MIT"}
                ]
            }
        ]
    }
    result = remove_main_license("MIT", "target.py", data)
    assert len(result["files"]) == 0

# --- UNIT TESTS: filter_contained_licenses ---

def test_filter_contained_licenses_logic():
    """
    Test logic to filter out redundant licenses that are contained within other license expressions.
    Example: 'MIT' should be removed if 'Apache-2.0 AND MIT' is present.
    """
    items = [
        {"license_spdx": "MIT"},
        {"license_spdx": "Apache-2.0 AND MIT"}
    ]
    res = filter_contained_licenses(items)
    assert len(res) == 1
    assert res[0]["license_spdx"] == "Apache-2.0 AND MIT"

def test_filter_contained_licenses_dirty_inputs():
    """
    Test robustness of filter_contained_licenses against dirty inputs
    like empty strings or None values.
    """
    items = [
        {"license_spdx": ""},
        {"license_spdx": None},
        {"license_spdx": "MIT"}
    ]
    res = filter_contained_licenses(items)
    assert len(res) == 3

# --- UNIT TESTS: regex_filter ---

def test_regex_filter_missing_rules_file():
    """
    Verify that regex_filter raises FileNotFoundError if the rules file is missing.
    """
    with patch("os.path.exists", return_value=False):
        with pytest.raises(FileNotFoundError):
            regex_filter({"files": []}, False)

def test_regex_filter_valid_tag_group_1(mock_rules_json):
    """
    Test regex filtering using the first capturing group of a pattern.
    Verifies extraction of SPDX ID from tags like 'SPDX-License-Identifier: MIT'.
    """
    data = {
        "files": [{
            "path": "file.c", "is_legal": False, "is_key_file": False, "score": 50,
            "matches": [{
                "license_spdx": "MIT",
                "matched_text": "SPDX-License-Identifier: MIT"
            }]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        assert len(result["files"]) == 1
        assert result["files"][0]["matches"][0]["license_spdx"] == "MIT"

def test_regex_filter_spdx_tag_group_3(mock_rules_json):
    """
    Test regex filtering with complex patterns involving multiple groups.
    Verifies that the correct group (3rd in this case) is extracted.
    """
    custom_rules = mock_rules_json.copy()
    custom_rules["spdx_tag_pattern"] = "(Tag: (.+))|(Alt: (.+))"
    data = {
        "files": [{
            "path": "file.c", "is_legal": False, "is_key_file": False, "score": 50,
            "matches": [{
                "license_spdx": "MIT",
                "matched_text": "Alt: Apache-2.0"
            }]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(custom_rules))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        assert len(result["files"]) == 1
        assert "Apache-2.0" in result["files"][0]["matches"][0]["license_spdx"]

def test_regex_filter_valid_link_fallback(mock_rules_json):
    """
    Test fallback behavior when license text is unknown but contains a valid URL.
    Verifies that the entry is kept if the URL matches allowed patterns.
    """
    data = {
        "files": [{
            "path": "link.txt", "is_legal": False, "is_key_file": False, "score": 50,
            "matches": [{
                "license_spdx": "LicenseRef-scancode-unknown",
                "matched_text": "Check https://opensource.org/licenses/MIT"
            }]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        assert len(result["files"]) == 1
        assert result["files"][0]["matches"][0]["license_spdx"] == "LicenseRef-scancode-unknown"

def test_regex_filter_scancode_id_checks(mock_rules_json):
    """
    Test handling of specific ScanCode internal IDs (e.g., LicenseRef-scancode-generic).
    Verifies that 'generic' IDs are treated differently from valid licenses or unknown refs.
    """
    data = {
        "files": [{
            "path": "checks.txt", "is_legal": False, "is_key_file": False, "score": 50,
            "matches": [
                {"license_spdx": "LicenseRef-scancode-generic",
                 "matched_text": "Valid Link: https://opensource.org/licenses/MIT"},
                {"license_spdx": "LicenseRef-unknown-license",
                 "matched_text": "Valid Link: https://opensource.org/licenses/MIT"},
                {"license_spdx": "Apache-2.0", "matched_text": "Valid Link: https://opensource.org/licenses/MIT"}
            ]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        matches = result["files"][0]["matches"]
        assert matches[0]["license_spdx"] == "LicenseRef-scancode-unknown"
        assert matches[1]["license_spdx"] == "LicenseRef-scancode-unknown"
        assert matches[2]["license_spdx"] == "Apache-2.0"

# --- UNIT TESTS: check_license_spdx_duplicates ---

def test_check_license_spdx_duplicates_dirty_data():
    """
    Test duplicate check with dirty data (None or empty strings).
    Verifies that invalid values are cleaned up while valid ones remain.
    """
    data = {
        "files": [
            {
                "path": "test.py", "score": 100,
                "matches": [
                    {"license_spdx": None, "matched_text": "t1"},
                    {"license_spdx": "", "matched_text": "t2"},
                    {"license_spdx": "MIT", "matched_text": "t3"}
                ]
            }
        ]
    }
    result = check_license_spdx_duplicates(data)
    matches = result["files"][0]["matches"]
    assert len(matches) == 1
    assert matches[0]["license_spdx"] == "MIT"

def test_check_license_spdx_duplicates_deduplication():
    """
    Test the deduplication logic for identical SPDX IDs.
    Verifies that case-insensitive duplicates are merged.
    """
    data = {
        "files": [{
            "path": "test.py", "score": 100,
            "matches": [
                {"license_spdx": "MIT", "matched_text": "t1"},
                {"license_spdx": "mit", "matched_text": "t2"}
            ]
        }]
    }
    result = check_license_spdx_duplicates(data)
    assert len(result["files"][0]["matches"]) == 1

# --- INTEGRATION TESTS ---

def test_filter_licenses_integration(mock_scancode_data, mock_rules_json):
    """
    Integration test for the main filter_licenses function.
    Verifies that the entire pipeline (load, filter, remove main, clean) works together.
    """
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = filter_licenses(mock_scancode_data, main_spdx="UNKNOWN", path="")
        assert len(result["files"]) == 1
        assert result["files"][0]["path"] == "file1.py"