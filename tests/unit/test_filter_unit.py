"""
test: services/scanner/test_filter_unit.py

Questo modulo contiene test unitari per le funzioni di filtro in
`app.services.analysis.license_filtering`. Si concentra sulla logica di filtraggio delle issue
in base a compatibilità, tipo di licenza, pattern di file, presenza di suggerimenti LLM e altro.

La suite copre:
1. Filtraggio per compatibilità: Selezione di issue compatibili/incompatibili/condizionali.
2. Filtraggio per tipo di licenza: Inclusione/esclusione di licenze specifiche o pattern.
3. Filtraggio per path/file: Inclusione di file o directory specifiche.
4. Filtraggio per presenza di suggerimenti LLM: Issue con/ senza suggerimenti.
5. Edge case: Gestione di input vuoti, None, issue malformate.
"""

import pytest
import json
import os
import re
from unittest.mock import patch, mock_open

# Import functions to be tested
from app.services.scanner.filter import (
    filter_licenses,
    build_minimal_json,
    remove_main_license,
    regex_filter,
    check_license_spdx_duplicates,
    filter_contained_licenses
)

# --- FIXTURES ---

@pytest.fixture(autouse=True)
def setup_filter_test_env():
    """
    Configura l'ambiente per tutti i test.
    Patch MINIMAL_JSON_BASE_DIR direttamente nel modulo scanner.filter
    e mocka os.makedirs per prevenire modifiche al file system.
    """
    # Questo patch funziona solo se MINIMAL_JSON_BASE_DIR è importato correttamente in filter.py
    with patch("app.services.scanner.filter.MINIMAL_JSON_BASE_DIR", "/mock/dir"), \
            patch("os.makedirs"):
        yield

@pytest.fixture
def mock_scancode_data():
    """
    Fixture che fornisce dati di esempio grezzi dalla struttura di ScanCode.
    Contiene file legali e non legali con vari tipi di corrispondenza.
    """
    return {
        "files": [
            {
                "path": "file1.py",
                "is_legal": False,
                "is_key_file": False,
                "percentage_of_license_text": 90.5,
                "license_detections": [
                    {
                        "matches": [
                            {
                                "from_file": "file1.py",
                                "license_expression_spdx": "MIT",
                                "matched_text": "Permission is hereby granted..."
                            },
                            {
                                "from_file": "file1.py",
                                "license_expression_spdx": "LicenseRef-scancode-unknown",
                                "matched_text": "foobar"
                            }
                        ]
                    }
                ]
            },
            {
                "path": "README.md",
                "is_legal": False,
                "is_key_file": False,
                "percentage_of_license_text": 10.0,
                "license_detections": [
                    {
                        "matches": [
                            {
                                "from_file": "README.md",
                                "license_expression_spdx": "MIT",
                                "matched_text": "See the MIT license file for details."
                            }
                        ]
                    }
                ]
            }
        ]
    }

@pytest.fixture
def mock_rules_json():
    """
    Fixture che simula il contenuto di license_rules.json.
    Definisce pattern per testo ignorato, changelog, tag SPDX e link validi.
    """
    return {
        "ignore_patterns": [
            "(see\\s+(the\\s+)?license\\s+file)",
            "generated by"
        ],
        "changelog_patterns": [
            "migrated to"
        ],
        "spdx_tag_pattern": "SPDX-License-Identifier:\\s*([\\w\\.\\-\\+]+)",
        "valid_license_text_patterns": [
            "Permission is hereby granted",
            "Licensed under the Apache License"
        ],
        "valid_license_link_patterns": [
            "https?://opensource\\.org/licenses/"
        ],
        "min_matched_text_length": 10
    }

# --- UNIT TESTS: build_minimal_json ---

def test_build_minimal_json(mock_scancode_data):
    """
    Test della creazione standard della struttura JSON minimale.
    Verifica che i file siano correttamente analizzati e mappati allo schema minimale.
    """
    with patch("builtins.open", mock_open()) as mocked_file, \
            patch("os.makedirs") as mock_makedirs:
        result = build_minimal_json(mock_scancode_data)

        # Verifica il percorso dummy patchato dal fixture
        mock_makedirs.assert_called_with("/mock/dir", exist_ok=True)

        files = result["files"]
        assert len(files) == 2
        f1 = files[0]
        assert f1["path"] == "file1.py"
        assert len(f1["matches"]) == 1
        assert f1["matches"][0]["license_spdx"] == "MIT"

def test_build_minimal_json_edge_cases():
    """
    Test dei casi limite per build_minimal_json:
    - Mancanza di 'path' nell'entry del file.
    - Discrepanza tra 'path' e 'from_file'.
    Verifica che le voci non valide siano escluse.
    """
    data = {
        "files": [
            {"path": None},
            {
                "path": "a.py",
                "is_legal": False, "is_key_file": False, "percentage_of_license_text": 0,
                "license_detections": [{
                    "matches": [{
                        "from_file": "other.py",
                        "license_expression_spdx": "MIT",
                        "matched_text": "text"
                    }]
                }]
            }
        ]
    }
    with patch("builtins.open", mock_open()), \
            patch("os.makedirs"):
        res = build_minimal_json(data)
        assert len(res["files"]) == 0

# --- UNIT TESTS: remove_main_license ---

def test_remove_main_license_single():
    """
    Test della rimozione del file di licenza principale dall'elenco.
    Verifica che se un file corrisponde al percorso/SPDX della licenza principale, venga filtrato.
    """
    data = {
        "files": [
            {"path": "LICENSE", "matches": [{"license_spdx": "MIT"}]},
            {"path": "app.py", "matches": [{"license_spdx": "Apache-2.0"}]}
        ]
    }
    result = remove_main_license("MIT", "LICENSE", data)
    assert len(result["files"]) == 1
    assert result["files"][0]["path"] == "app.py"

def test_remove_main_license_multiple_matches_value_error():
    """
    Test del comportamento quando il file target ha più corrispondenze di licenza.
    Assicura una gestione rigorosa dove i file ambigui potrebbero essere rimossi o gestiti in modo sicuro.
    """
    data = {
        "files": [
            {
                "path": "target.py",
                "matches": [
                    {"license_spdx": "MIT"},
                    {"license_spdx": "MIT"}
                ]
            }
        ]
    }
    result = remove_main_license("MIT", "target.py", data)
    assert len(result["files"]) == 0

def test_remove_main_license_value_error():
    """
    Test che verifica che l'errore ValueError durante la rimozione venga catturato e ignorato.
    Questo simula una condizione di gara o uno stato in cui l'elemento da rimuovere
    non è più nell'elenco quando viene chiamato remove().
    """
    class ErrorList(list):
        def remove(self, value):
            raise ValueError("Test Error")

    # Costruisci i dati con l'elenco personalizzato
    file_entry = {"path": "target.py", "matches": [{"license_spdx": "MIT"}]}
    files_list = ErrorList([file_entry])
    data = {"files": files_list}
    
    # Questo dovrebbe trovare "target.py" con "MIT" e provare a rimuoverlo, attivando ValueError
    result = remove_main_license("MIT", "target.py", data)
    
    # Il risultato dovrebbe ancora contenere il file perché la rimozione è fallita ed è stata catturata
    assert len(result["files"]) == 1
    assert result["files"][0]["path"] == "target.py"

def test_remove_main_license_path_match_spdx_mismatch():
    """
    Test che verifica che se il percorso corrisponde al file di licenza principale ma lo SPDX no,
    il file NON venga rimosso.
    """
    data = {
        "files": [
            {"path": "LICENSE", "matches": [{"license_spdx": "Apache-2.0"}]}
        ]
    }
    # Prova a rimuovere "LICENSE" assumendo che sia "MIT". In realtà è "Apache-2.0".
    result = remove_main_license("MIT", "LICENSE", data)
    assert len(result["files"]) == 1
    assert result["files"][0]["path"] == "LICENSE"

# --- UNIT TESTS: filter_contained_licenses ---

def test_filter_contained_licenses_logic():
    """
    Test della logica per filtrare le licenze ridondanti che sono contenute all'interno di altre espressioni di licenza.
    Esempio: 'MIT' dovrebbe essere rimosso se 'Apache-2.0 AND MIT' è presente.
    """
    items = [
        {"license_spdx": "MIT"},
        {"license_spdx": "Apache-2.0 AND MIT"}
    ]
    res = filter_contained_licenses(items)
    assert len(res) == 1
    assert res[0]["license_spdx"] == "Apache-2.0 AND MIT"

def test_filter_contained_licenses_dirty_inputs():
    """
    Test della robustezza di filter_contained_licenses contro input sporchi
    come stringhe vuote o valori None.
    """
    items = [
        {"license_spdx": ""},
        {"license_spdx": None},
        {"license_spdx": "MIT"}
    ]
    res = filter_contained_licenses(items)
    assert len(res) == 3

# --- UNIT TESTS: regex_filter ---

def test_regex_filter_missing_rules_file():
    """
    Verifica che regex_filter sollevi FileNotFoundError se il file delle regole è mancante.
    """
    with patch("os.path.exists", return_value=False):
        with pytest.raises(FileNotFoundError):
            regex_filter({"files": []}, False)

def test_load_rules_patterns_invalid_regex(mock_rules_json):
    """
    Test che verifica che i pattern regex non validi nel file delle regole siano ignorati in modo sicuro (catturati da try/except).
    """
    bad_rules = mock_rules_json.copy()
    bad_rules["valid_license_text_patterns"] = ["(["] # Regex non valido
    bad_rules["valid_license_link_patterns"] = ["*"]  # Regex non valido

    with patch("builtins.open", mock_open(read_data=json.dumps(bad_rules))), \
            patch("os.path.exists", return_value=True):
        # Non dovrebbe sollevare eccezioni
        result = regex_filter({"files": []}, False)
        assert result == {"files": []}

def test_regex_filter_skip_key_files(mock_rules_json):
    """
    Test che verifica che i file contrassegnati come 'is_key_file' siano saltati SOLO quando detected_main_spdx è True.
    """
    data = {
        "files": [
            {
                "path": "LICENSE",
                "is_legal": False, # Deve essere False per attivare il controllo
                "is_key_file": True,
                "score": 100,
                # Usa matched_text che passa la validazione regex ("Permission is hereby granted")
                # definita in mock_rules_json, altrimenti il file viene filtrato come corrispondenza non valida
                "matches": [{"license_spdx": "MIT", "matched_text": "Permission is hereby granted"}]
            }
        ]
    }

    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):

        # Scenario 1: detected_main_spdx = True -> File saltato (file chiave)
        res1 = regex_filter(data, detected_main_spdx=True)
        assert len(res1["files"]) == 0

        # Scenario 2: detected_main_spdx = False -> File mantenuto (controllo file chiave ignorato)
        res2 = regex_filter(data, detected_main_spdx=False)
        assert len(res2["files"]) == 1

def test_regex_filter_detected_main_true_not_key_file(mock_rules_json):
    """
    Test che verifica che se detected_main_spdx è True ma is_key_file è False,
    il file NON venga saltato.
    """
    data = {
        "files": [{
            "path": "normal.py",
            "is_legal": False,
            "is_key_file": False, # Non è un file chiave
            "matches": [{"license_spdx": "MIT", "matched_text": "Permission is hereby granted"}]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, detected_main_spdx=True)
        assert len(result["files"]) == 1

def test_regex_filter_is_legal_file(mock_rules_json):
    """
    Test che verifica che i file contrassegnati come 'is_legal' siano preservati nell'output
    senza subire filtraggio regex.
    """
    data = {
        "files": [{
            "path": "legal_file.txt",
            "is_legal": True,
            "is_key_file": False,
            "score": 100,
            # Anche con corrispondenze che potrebbero tecnicamente fallire la validazione (o corrispondenze vuote),
            # i file legali vengono passati attraverso "così com'è" dalla logica del filtro.
            "matches": [{"license_spdx": "SomeLicense", "matched_text": "Some text"}]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        assert len(result["files"]) == 1
        assert result["files"][0]["path"] == "legal_file.txt"
        # Le corrispondenze dovrebbero essere preservate così come sono
        assert result["files"][0]["matches"][0]["license_spdx"] == "SomeLicense"

def test_regex_filter_valid_tag_group_1(mock_rules_json):
    """
    Test del filtraggio regex utilizzando il primo gruppo di cattura di un pattern.
    Verifica l'estrazione dell'ID SPDX da tag come 'SPDX-License-Identifier: MIT'.
    """
    data = {
        "files": [{
            "path": "file.c", "is_legal": False, "is_key_file": False, "score": 50,
            "matches": [{
                "license_spdx": "MIT",
                "matched_text": "SPDX-License-Identifier: MIT"
            }]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        assert len(result["files"]) == 1
        assert result["files"][0]["matches"][0]["license_spdx"] == "MIT"

def test_regex_filter_spdx_tag_group_3(mock_rules_json):
    """
    Test del filtraggio regex con pattern complessi che coinvolgono più gruppi.
    Verifica che il gruppo corretto (il 3° in questo caso) venga estratto.
    """
    custom_rules = mock_rules_json.copy()
    custom_rules["spdx_tag_pattern"] = "(Tag: (.+))|(Alt: (.+))"
    data = {
        "files": [{
            "path": "file.c", "is_legal": False, "is_key_file": False, "score": 50,
            "matches": [{
                "license_spdx": "MIT",
                "matched_text": "Alt: Apache-2.0"
            }]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(custom_rules))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        assert len(result["files"]) == 1
        assert "Apache-2.0" in result["files"][0]["matches"][0]["license_spdx"]

def test_regex_filter_valid_link_fallback(mock_rules_json):
    """
    Test del comportamento di fallback quando il testo della licenza è sconosciuto ma contiene un URL valido.
    Verifica che l'entry venga mantenuta se l'URL corrisponde ai pattern consentiti.
    """
    data = {
        "files": [{
            "path": "link.txt", "is_legal": False, "is_key_file": False, "score": 50,
            "matches": [{
                "license_spdx": "LicenseRef-scancode-unknown",
                "matched_text": "Check https://opensource.org/licenses/MIT"
            }]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        assert len(result["files"]) == 1
        assert result["files"][0]["matches"][0]["license_spdx"] == "LicenseRef-scancode-unknown"

def test_regex_filter_scancode_id_checks(mock_rules_json):
    """
    Test della gestione di ID interni specifici di ScanCode (ad es., LicenseRef-scancode-generic).
    Verifica che gli ID 'generic' siano trattati in modo diverso da licenze valide o riferimenti sconosciuti.
    """
    data = {
        "files": [{
            "path": "checks.txt", "is_legal": False, "is_key_file": False, "score": 50,
            "matches": [
                {"license_spdx": "LicenseRef-scancode-generic",
                 "matched_text": "Valid Link: https://opensource.org/licenses/MIT"},
                {"license_spdx": "LicenseRef-unknown-license",
                 "matched_text": "Valid Link: https://opensource.org/licenses/MIT"},
                {"license_spdx": "Apache-2.0", "matched_text": "Valid Link: https://opensource.org/licenses/MIT"}
            ]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        matches = result["files"][0]["matches"]
        assert matches[0]["license_spdx"] == "LicenseRef-scancode-unknown"
        assert matches[1]["license_spdx"] == "LicenseRef-scancode-unknown"
        assert matches[2]["license_spdx"] == "Apache-2.0"

def test_regex_filter_no_valid_matches(mock_rules_json):
    """
    Test che verifica che i file senza corrispondenze valide (testo non nella whitelist) siano esclusi dall'output.
    """
    data = {
        "files": [{
            "path": "garbage.txt", "is_legal": False, "is_key_file": False, "score": 10,
            "matches": [{"license_spdx": "MIT", "matched_text": "This text is not in the whitelist rules."}]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        # Il file dovrebbe essere rimosso perché valid_matches è vuoto
        assert len(result["files"]) == 0

def test_regex_filter_empty_extraction(mock_rules_json):
    """
    Test di uno scenario in cui la regex del tag SPDX corrisponde ma cattura una stringa vuota.
    La corrispondenza dovrebbe essere scartata.
    """
    # Regola che corrisponde a "Tag: " ma cattura "" nel gruppo 1
    custom_rules = mock_rules_json.copy()
    custom_rules["spdx_tag_pattern"] = "Tag: (.*)"

    data = {
        "files": [{
            "path": "empty.txt", "is_legal": False, "is_key_file": False, "score": 10,
            "matches": [{"license_spdx": "MIT", "matched_text": "Tag: "}]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(custom_rules))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        # La corrispondenza corrisponde alla regex, ma il gruppo estratto è una stringa vuota.
        # final_spdx diventa "", quindi 'if final_spdx:' è False.
        # valid_matches è vuota -> file rimosso.
        assert len(result["files"]) == 0

# --- UNIT TESTS: check_license_spdx_duplicates ---

def test_check_license_spdx_duplicates_dirty_data():
    """
    Test del controllo dei duplicati con dati sporchi (None o stringhe vuote).
    Verifica che i valori non validi vengano puliti mentre quelli validi rimangono.
    """
    data = {
        "files": [
            {
                "path": "test.py", "score": 100,
                "matches": [
                    {"license_spdx": None, "matched_text": "t1"},
                    {"license_spdx": "", "matched_text": "t2"},
                    {"license_spdx": "MIT", "matched_text": "t3"}
                ]
            }
        ]
    }
    result = check_license_spdx_duplicates(data)
    matches = result["files"][0]["matches"]
    assert len(matches) == 1
    assert matches[0]["license_spdx"] == "MIT"

def test_check_license_spdx_duplicates_deduplication():
    """
    Test della logica di deduplicazione per ID SPDX identici.
    Verifica che i duplicati con differenze di maiuscole/minuscole vengano uniti.
    """
    data = {
        "files": [{
            "path": "test.py", "score": 100,
            "matches": [
                {"license_spdx": "MIT", "matched_text": "t1"},
                {"license_spdx": "mit", "matched_text": "t2"}
            ]
        }]
    }
    result = check_license_spdx_duplicates(data)
    assert len(result["files"][0]["matches"]) == 1

def test_check_license_spdx_duplicates_all_invalid():
    """
    Test di uno scenario in cui un file ha delle corrispondenze ma tutte hanno SPDX non valido/vuoto.
    Il file dovrebbe essere escluso dai risultati unici.
    """
    data = {
        "files": [{
            "path": "invalid.txt", "score": 10,
            "matches": [
                {"license_spdx": "", "matched_text": "foo"},
                {"license_spdx": None, "matched_text": "bar"}
            ]
        }]
    }
    result = check_license_spdx_duplicates(data)
    # spdx_uniques dovrebbe essere vuoto, quindi il file non viene aggiunto
    assert len(result["files"]) == 0

# --- INTEGRATION TESTS ---

def test_filter_licenses_integration(mock_scancode_data, mock_rules_json):
    """
    Test di integrazione per la funzione principale filter_licenses.
    Verifica che l'intero pipeline (caricamento, filtraggio, rimozione principale, pulizia) funzioni insieme.
    """
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = filter_licenses(mock_scancode_data, main_spdx="UNKNOWN", path="")
        assert len(result["files"]) == 1
        assert result["files"][0]["path"] == "file1.py"