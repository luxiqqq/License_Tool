"""
test: services/scanner/test_filter_unit.py

Unit tests for the filter service module.
This module validates the logic for filtering ScanCode results, including:
- Building minimal JSON representations.
- Removing main license files from analysis.
- Regex-based filtering of invalid or irrelevant matches.
- Handling duplicate license entries.
- Logic for filtering contained/subset licenses.
"""

import pytest
import json
import os
import re
from unittest.mock import patch, mock_open

# Import functions to be tested
from app.services.scanner.filter import (
    filter_licenses,
    build_minimal_json,
    remove_main_license,
    regex_filter,
    check_license_spdx_duplicates,
    filter_contained_licenses
)

# --- FIXTURES ---

@pytest.fixture(autouse=True)
def setup_filter_test_env():
    """
    Configures the environment for all tests.
    Patches MINIMAL_JSON_BASE_DIR directly in the scanner.filter module
    and mocks os.makedirs to prevent file system changes.
    """
    # This patch only works if MINIMAL_JSON_BASE_DIR is imported correctly in filter.py
    with patch("app.services.scanner.filter.MINIMAL_JSON_BASE_DIR", "/mock/dir"), \
            patch("os.makedirs"):
        yield

@pytest.fixture
def mock_scancode_data():
    """
    Fixture providing raw sample data structure from ScanCode.
    Contains legal and illegal files with various match types.
    """
    return {
        "files": [
            {
                "path": "file1.py",
                "is_legal": False,
                "is_key_file": False,
                "percentage_of_license_text": 90.5,
                "license_detections": [
                    {
                        "matches": [
                            {
                                "from_file": "file1.py",
                                "license_expression_spdx": "MIT",
                                "matched_text": "Permission is hereby granted..."
                            },
                            {
                                "from_file": "file1.py",
                                "license_expression_spdx": "LicenseRef-scancode-unknown",
                                "matched_text": "foobar"
                            }
                        ]
                    }
                ]
            },
            {
                "path": "README.md",
                "is_legal": False,
                "is_key_file": False,
                "percentage_of_license_text": 10.0,
                "license_detections": [
                    {
                        "matches": [
                            {
                                "from_file": "README.md",
                                "license_expression_spdx": "MIT",
                                "matched_text": "See the MIT license file for details."
                            }
                        ]
                    }
                ]
            }
        ]
    }

@pytest.fixture
def mock_rules_json():
    """
    Fixture simulating the content of license_rules.json.
    Defines patterns for ignored text, changelogs, SPDX tags, and valid links.
    """
    return {
        "ignore_patterns": [
            "(see\\s+(the\\s+)?license\\s+file)",
            "generated by"
        ],
        "changelog_patterns": [
            "migrated to"
        ],
        "spdx_tag_pattern": "SPDX-License-Identifier:\\s*([\\w\\.\\-\\+]+)",
        "valid_license_text_patterns": [
            "Permission is hereby granted",
            "Licensed under the Apache License"
        ],
        "valid_license_link_patterns": [
            "https?://opensource\\.org/licenses/"
        ],
        "min_matched_text_length": 10
    }

# --- UNIT TESTS: build_minimal_json ---

def test_build_minimal_json(mock_scancode_data):
    """
    Test the standard creation of the minimal JSON structure.
    Verifies that files are correctly parsed and mapped to the minimal schema.
    """
    with patch("builtins.open", mock_open()) as mocked_file, \
            patch("os.makedirs") as mock_makedirs:
        result = build_minimal_json(mock_scancode_data)

        # Verify dummy path patched by fixture
        mock_makedirs.assert_called_with("/mock/dir", exist_ok=True)

        files = result["files"]
        assert len(files) == 2
        f1 = files[0]
        assert f1["path"] == "file1.py"
        assert len(f1["matches"]) == 1
        assert f1["matches"][0]["license_spdx"] == "MIT"

def test_build_minimal_json_edge_cases():
    """
    Test edge cases for build_minimal_json:
    - Missing 'path' in file entry.
    - Mismatch between 'path' and 'from_file'.
    Verifies that invalid entries are excluded.
    """
    data = {
        "files": [
            {"path": None},
            {
                "path": "a.py",
                "is_legal": False, "is_key_file": False, "percentage_of_license_text": 0,
                "license_detections": [{
                    "matches": [{
                        "from_file": "other.py",
                        "license_expression_spdx": "MIT",
                        "matched_text": "text"
                    }]
                }]
            }
        ]
    }
    with patch("builtins.open", mock_open()), \
            patch("os.makedirs"):
        res = build_minimal_json(data)
        assert len(res["files"]) == 0

# --- UNIT TESTS: remove_main_license ---

def test_remove_main_license_single():
    """
    Test removing the main license file from the list.
    Verifies that if a file matches the main license path/SPDX, it is filtered out.
    """
    data = {
        "files": [
            {"path": "LICENSE", "matches": [{"license_spdx": "MIT"}]},
            {"path": "app.py", "matches": [{"license_spdx": "Apache-2.0"}]}
        ]
    }
    result = remove_main_license("MIT", "LICENSE", data)
    assert len(result["files"]) == 1
    assert result["files"][0]["path"] == "app.py"

def test_remove_main_license_multiple_matches_value_error():
    """
    Test behavior when the target file has multiple license matches.
    Ensure strict handling where ambiguous files might be removed or handled gracefully.
    """
    data = {
        "files": [
            {
                "path": "target.py",
                "matches": [
                    {"license_spdx": "MIT"},
                    {"license_spdx": "MIT"}
                ]
            }
        ]
    }
    result = remove_main_license("MIT", "target.py", data)
    assert len(result["files"]) == 0

def test_remove_main_license_value_error():
    """
    Test that ValueError during removal is caught and ignored.
    This simulates a race condition or state where the item to be removed
    is no longer in the list by the time remove() is called.
    """
    class ErrorList(list):
        def remove(self, value):
            raise ValueError("Test Error")

    # Construct the data with the custom list
    file_entry = {"path": "target.py", "matches": [{"license_spdx": "MIT"}]}
    files_list = ErrorList([file_entry])
    data = {"files": files_list}
    
    # This should find "target.py" with "MIT" and try to remove it, triggering ValueError
    result = remove_main_license("MIT", "target.py", data)
    
    # Result should still contain the file because removal failed and was caught
    assert len(result["files"]) == 1
    assert result["files"][0]["path"] == "target.py"

def test_remove_main_license_path_match_spdx_mismatch():
    """
    Test that if the path matches the main license file but the SPDX does not,
    the file is NOT removed.
    """
    data = {
        "files": [
            {"path": "LICENSE", "matches": [{"license_spdx": "Apache-2.0"}]}
        ]
    }
    # Trying to remove "LICENSE" assuming it is "MIT". It is "Apache-2.0".
    result = remove_main_license("MIT", "LICENSE", data)
    assert len(result["files"]) == 1
    assert result["files"][0]["path"] == "LICENSE"

# --- UNIT TESTS: filter_contained_licenses ---

def test_filter_contained_licenses_logic():
    """
    Test logic to filter out redundant licenses that are contained within other license expressions.
    Example: 'MIT' should be removed if 'Apache-2.0 AND MIT' is present.
    """
    items = [
        {"license_spdx": "MIT"},
        {"license_spdx": "Apache-2.0 AND MIT"}
    ]
    res = filter_contained_licenses(items)
    assert len(res) == 1
    assert res[0]["license_spdx"] == "Apache-2.0 AND MIT"

def test_filter_contained_licenses_dirty_inputs():
    """
    Test robustness of filter_contained_licenses against dirty inputs
    like empty strings or None values.
    """
    items = [
        {"license_spdx": ""},
        {"license_spdx": None},
        {"license_spdx": "MIT"}
    ]
    res = filter_contained_licenses(items)
    assert len(res) == 3

# --- UNIT TESTS: regex_filter ---

def test_regex_filter_missing_rules_file():
    """
    Verify that regex_filter raises FileNotFoundError if the rules file is missing.
    """
    with patch("os.path.exists", return_value=False):
        with pytest.raises(FileNotFoundError):
            regex_filter({"files": []}, False)

def test_load_rules_patterns_invalid_regex(mock_rules_json):
    """
    Test that invalid regex patterns in rules file are safely ignored (caught by try/except).
    """
    bad_rules = mock_rules_json.copy()
    bad_rules["valid_license_text_patterns"] = ["(["] # Invalid regex
    bad_rules["valid_license_link_patterns"] = ["*"]  # Invalid regex

    with patch("builtins.open", mock_open(read_data=json.dumps(bad_rules))), \
            patch("os.path.exists", return_value=True):
        # Should not raise exception
        result = regex_filter({"files": []}, False)
        assert result == {"files": []}

def test_regex_filter_skip_key_files(mock_rules_json):
    """
    Test that files marked as 'is_key_file' are skipped ONLY when detected_main_spdx is True.
    """
    data = {
        "files": [
            {
                "path": "LICENSE",
                "is_legal": False, # Must be False to hit the check
                "is_key_file": True,
                "score": 100,
                # Use matched_text that passes regex validation ("Permission is hereby granted")
                # defined in mock_rules_json, otherwise the file is filtered out as invalid match
                "matches": [{"license_spdx": "MIT", "matched_text": "Permission is hereby granted"}]
            }
        ]
    }

    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):

        # Scenario 1: detected_main_spdx = True -> File skipped (key file)
        res1 = regex_filter(data, detected_main_spdx=True)
        assert len(res1["files"]) == 0

        # Scenario 2: detected_main_spdx = False -> File kept (key file check ignored)
        res2 = regex_filter(data, detected_main_spdx=False)
        assert len(res2["files"]) == 1

def test_regex_filter_detected_main_true_not_key_file(mock_rules_json):
    """
    Test that if detected_main_spdx is True but is_key_file is False,
    the file is NOT skipped.
    """
    data = {
        "files": [{
            "path": "normal.py",
            "is_legal": False,
            "is_key_file": False, # Not a key file
            "matches": [{"license_spdx": "MIT", "matched_text": "Permission is hereby granted"}]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, detected_main_spdx=True)
        assert len(result["files"]) == 1

def test_regex_filter_is_legal_file(mock_rules_json):
    """
    Test that files marked as 'is_legal' are preserved in the output
    without undergoing regex filtering.
    """
    data = {
        "files": [{
            "path": "legal_file.txt",
            "is_legal": True,
            "is_key_file": False,
            "score": 100,
            # Even with matches that might technically fail validation (or empty matches),
            # legal files are passed through "as is" by the filter logic.
            "matches": [{"license_spdx": "SomeLicense", "matched_text": "Some text"}]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        assert len(result["files"]) == 1
        assert result["files"][0]["path"] == "legal_file.txt"
        # Matches should be preserved as-is
        assert result["files"][0]["matches"][0]["license_spdx"] == "SomeLicense"

def test_regex_filter_valid_tag_group_1(mock_rules_json):
    """
    Test regex filtering using the first capturing group of a pattern.
    Verifies extraction of SPDX ID from tags like 'SPDX-License-Identifier: MIT'.
    """
    data = {
        "files": [{
            "path": "file.c", "is_legal": False, "is_key_file": False, "score": 50,
            "matches": [{
                "license_spdx": "MIT",
                "matched_text": "SPDX-License-Identifier: MIT"
            }]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        assert len(result["files"]) == 1
        assert result["files"][0]["matches"][0]["license_spdx"] == "MIT"

def test_regex_filter_spdx_tag_group_3(mock_rules_json):
    """
    Test regex filtering with complex patterns involving multiple groups.
    Verifies that the correct group (3rd in this case) is extracted.
    """
    custom_rules = mock_rules_json.copy()
    custom_rules["spdx_tag_pattern"] = "(Tag: (.+))|(Alt: (.+))"
    data = {
        "files": [{
            "path": "file.c", "is_legal": False, "is_key_file": False, "score": 50,
            "matches": [{
                "license_spdx": "MIT",
                "matched_text": "Alt: Apache-2.0"
            }]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(custom_rules))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        assert len(result["files"]) == 1
        assert "Apache-2.0" in result["files"][0]["matches"][0]["license_spdx"]

def test_regex_filter_valid_link_fallback(mock_rules_json):
    """
    Test fallback behavior when license text is unknown but contains a valid URL.
    Verifies that the entry is kept if the URL matches allowed patterns.
    """
    data = {
        "files": [{
            "path": "link.txt", "is_legal": False, "is_key_file": False, "score": 50,
            "matches": [{
                "license_spdx": "LicenseRef-scancode-unknown",
                "matched_text": "Check https://opensource.org/licenses/MIT"
            }]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        assert len(result["files"]) == 1
        assert result["files"][0]["matches"][0]["license_spdx"] == "LicenseRef-scancode-unknown"

def test_regex_filter_scancode_id_checks(mock_rules_json):
    """
    Test handling of specific ScanCode internal IDs (e.g., LicenseRef-scancode-generic).
    Verifies that 'generic' IDs are treated differently from valid licenses or unknown refs.
    """
    data = {
        "files": [{
            "path": "checks.txt", "is_legal": False, "is_key_file": False, "score": 50,
            "matches": [
                {"license_spdx": "LicenseRef-scancode-generic",
                 "matched_text": "Valid Link: https://opensource.org/licenses/MIT"},
                {"license_spdx": "LicenseRef-unknown-license",
                 "matched_text": "Valid Link: https://opensource.org/licenses/MIT"},
                {"license_spdx": "Apache-2.0", "matched_text": "Valid Link: https://opensource.org/licenses/MIT"}
            ]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        matches = result["files"][0]["matches"]
        assert matches[0]["license_spdx"] == "LicenseRef-scancode-unknown"
        assert matches[1]["license_spdx"] == "LicenseRef-scancode-unknown"
        assert matches[2]["license_spdx"] == "Apache-2.0"

def test_regex_filter_no_valid_matches(mock_rules_json):
    """
    Test that files with no valid matches (text not in whitelist) are excluded from output.
    """
    data = {
        "files": [{
            "path": "garbage.txt", "is_legal": False, "is_key_file": False, "score": 10,
            "matches": [{"license_spdx": "MIT", "matched_text": "This text is not in the whitelist rules."}]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        # File should be dropped because valid_matches is empty
        assert len(result["files"]) == 0

def test_regex_filter_empty_extraction(mock_rules_json):
    """
    Test scenario where SPDX tag regex matches but captures an empty string.
    The match should be discarded.
    """
    # Rule that matches "Tag: " but captures "" in group 1
    custom_rules = mock_rules_json.copy()
    custom_rules["spdx_tag_pattern"] = "Tag: (.*)"

    data = {
        "files": [{
            "path": "empty.txt", "is_legal": False, "is_key_file": False, "score": 10,
            "matches": [{"license_spdx": "MIT", "matched_text": "Tag: "}]
        }]
    }
    with patch("builtins.open", mock_open(read_data=json.dumps(custom_rules))), \
            patch("os.path.exists", return_value=True):
        result = regex_filter(data, False)
        # Match matches regex, but extracted group is empty string.
        # final_spdx becomes "", so 'if final_spdx:' is False.
        # valid_matches empty -> file dropped.
        assert len(result["files"]) == 0

# --- UNIT TESTS: check_license_spdx_duplicates ---

def test_check_license_spdx_duplicates_dirty_data():
    """
    Test duplicate check with dirty data (None or empty strings).
    Verifies that invalid values are cleaned up while valid ones remain.
    """
    data = {
        "files": [
            {
                "path": "test.py", "score": 100,
                "matches": [
                    {"license_spdx": None, "matched_text": "t1"},
                    {"license_spdx": "", "matched_text": "t2"},
                    {"license_spdx": "MIT", "matched_text": "t3"}
                ]
            }
        ]
    }
    result = check_license_spdx_duplicates(data)
    matches = result["files"][0]["matches"]
    assert len(matches) == 1
    assert matches[0]["license_spdx"] == "MIT"

def test_check_license_spdx_duplicates_deduplication():
    """
    Test the deduplication logic for identical SPDX IDs.
    Verifies that case-insensitive duplicates are merged.
    """
    data = {
        "files": [{
            "path": "test.py", "score": 100,
            "matches": [
                {"license_spdx": "MIT", "matched_text": "t1"},
                {"license_spdx": "mit", "matched_text": "t2"}
            ]
        }]
    }
    result = check_license_spdx_duplicates(data)
    assert len(result["files"][0]["matches"]) == 1

def test_check_license_spdx_duplicates_all_invalid():
    """
    Test scenario where a file has matches but all have invalid/empty SPDX.
    The file should be excluded from the unique results.
    """
    data = {
        "files": [{
            "path": "invalid.txt", "score": 10,
            "matches": [
                {"license_spdx": "", "matched_text": "foo"},
                {"license_spdx": None, "matched_text": "bar"}
            ]
        }]
    }
    result = check_license_spdx_duplicates(data)
    # spdx_uniques should be empty, so file is not appended
    assert len(result["files"]) == 0

# --- INTEGRATION TESTS ---

def test_filter_licenses_integration(mock_scancode_data, mock_rules_json):
    """
    Integration test for the main filter_licenses function.
    Verifies that the entire pipeline (load, filter, remove main, clean) works together.
    """
    with patch("builtins.open", mock_open(read_data=json.dumps(mock_rules_json))), \
            patch("os.path.exists", return_value=True):
        result = filter_licenses(mock_scancode_data, main_spdx="UNKNOWN", path="")
        assert len(result["files"]) == 1
        assert result["files"][0]["path"] == "file1.py"